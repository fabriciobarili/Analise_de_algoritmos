def block_partition(A, B, l, r, pivot, counters):
    offsetsL = [0] * B
    offsetsR = [0] * B
    startL, startR, numL, numR = 0, 0, 0, 0
    
    while r - l + 1 > 2 * B:  # Loop principal
        # Preenchimento do buffer esquerdo
        if numL == 0:
            startL = 0
            for i in range(B):
                if l + i <= r:  # Verifica limite do array
                    counters['comparacoes'] += 1
                    if A[l + i] <= pivot:
                        offsetsL[numL] = i
                        numL += 1
        
        # Preenchimento do buffer direito
        if numR == 0:
            startR = 0
            for i in range(B):
                if r - i >= l:  # Verifica limite do array
                    counters['comparacoes'] += 1
                    if A[r - i] >= pivot:
                        offsetsR[numR] = i
                        numR += 1
        
        # Número de trocas a serem feitas neste passo
        num = min(numL, numR)
        
        # Realiza as trocas
        for j in range(num):
            left_idx = l + offsetsL[startL + j]
            right_idx = r - offsetsR[startR + j]
            A[left_idx], A[right_idx] = A[right_idx], A[left_idx]
            counters['trocas'] += 1
        
        # Atualiza contadores
        numL -= num
        numR -= num
        startL += num
        startR += num
        
        # Atualiza limites se buffers esgotados
        if numL == 0:
            l += B
        if numR == 0:
            r -= B
    
    # Processa elementos restantes (varredura tradicional)
    i = l
    for j in range(l, r + 1):
        counters['comparacoes'] += 1
        if A[j] <= pivot:
            if i != j:
                A[i], A[j] = A[j], A[i]
                counters['trocas'] += 1
            i += 1
    
    return i - 1  # Retorna a posição final do pivô
